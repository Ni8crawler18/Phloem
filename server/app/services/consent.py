"""
Consent Service
Business logic for consent management and cryptographic receipt generation.

This module handles:
- Consent receipt generation with HMAC-SHA256 signatures
- Signature verification for tamper detection
- Consent existence checking

All consent receipts are cryptographically signed to ensure:
- Data integrity (tampering detection)
- Non-repudiation (proof of consent)
- Compliance with DPDP Section 6(3) transparency requirements
"""
import json
import hmac
import hashlib
from typing import Dict, Any

from sqlalchemy.orm import Session

from app.config import settings
from app.database import safe_commit
from app.models import Consent, ConsentReceipt, User, Purpose, DataFiduciary


def generate_consent_signature(data: Dict[str, Any], fiduciary_id: int) -> str:
    """
    Generate HMAC-SHA256 signature for consent data.

    Creates a tamper-proof signature using the application's SECRET_KEY
    combined with the fiduciary ID. This ensures signatures can only be
    generated by the server and are unique per fiduciary.

    Args:
        data: Dictionary of consent data to sign.
        fiduciary_id: ID of the fiduciary for key derivation.

    Returns:
        Hexadecimal string of the HMAC-SHA256 signature.

    Example:
        >>> signature = generate_consent_signature(
        ...     {"consent_uuid": "abc-123", "user": {"email": "user@example.com"}},
        ...     fiduciary_id=1
        ... )
        >>> len(signature)  # SHA256 produces 64 hex characters
        64
    """
    # Derive signing key from secret + fiduciary ID
    signing_key = f"{settings.SECRET_KEY}:{fiduciary_id}".encode()

    # Serialize data deterministically (sorted keys)
    message = json.dumps(data, sort_keys=True).encode()

    return hmac.new(signing_key, message, hashlib.sha256).hexdigest()


def verify_consent_signature(
    data: Dict[str, Any],
    signature: str,
    fiduciary_id: int
) -> bool:
    """
    Verify HMAC signature of consent receipt data.

    Uses constant-time comparison to prevent timing attacks.

    Args:
        data: The consent data that was signed.
        signature: The signature to verify.
        fiduciary_id: ID of the fiduciary for key derivation.

    Returns:
        True if signature is valid, False otherwise.

    Example:
        >>> data = {"consent_uuid": "abc-123"}
        >>> sig = generate_consent_signature(data, 1)
        >>> verify_consent_signature(data, sig, 1)
        True
        >>> verify_consent_signature(data, "invalid", 1)
        False
    """
    expected = generate_consent_signature(data, fiduciary_id)
    return hmac.compare_digest(signature, expected)


def generate_consent_receipt(
    db: Session,
    consent: Consent,
    user: User,
    purpose: Purpose,
    fiduciary: DataFiduciary
) -> ConsentReceipt:
    """
    Generate a consent receipt with HMAC-SHA256 signature.

    Creates a legally compliant consent receipt per DPDP Section 6(3)
    transparency requirements. The receipt contains:
    - Consent details and timestamps
    - User (data principal) information
    - Fiduciary (data controller) information
    - Purpose and data processing details
    - Cryptographic signature for verification

    Args:
        db: Database session for persistence.
        consent: The consent record to generate receipt for.
        user: The data principal who granted consent.
        purpose: The purpose the consent was granted for.
        fiduciary: The data fiduciary receiving consent.

    Returns:
        The created ConsentReceipt with signature.

    Raises:
        HTTPException: If database commit fails.
    """
    # Build receipt data structure
    receipt_data = {
        "consent_uuid": consent.uuid,
        "user": {
            "name": user.name,
            "email": user.email
        },
        "fiduciary": {
            "name": fiduciary.name,
            "contact": fiduciary.contact_email
        },
        "purpose": {
            "name": purpose.name,
            "description": purpose.description,
            "data_categories": json.loads(purpose.data_categories),
            "legal_basis": purpose.legal_basis,
            "retention_days": purpose.retention_period_days
        },
        "granted_at": consent.granted_at.isoformat(),
        "expires_at": consent.expires_at.isoformat() if consent.expires_at else None,
        "version": consent.consent_version
    }

    # Generate tamper-proof signature
    signature = generate_consent_signature(receipt_data, fiduciary.id)

    # Create and persist receipt
    receipt = ConsentReceipt(
        consent_id=consent.id,
        receipt_data=json.dumps(receipt_data),
        signature=signature
    )
    db.add(receipt)
    safe_commit(db, "generate consent receipt")
    db.refresh(receipt)

    return receipt


def check_consent_exists(db: Session, user_id: int, purpose_id: int) -> bool:
    """
    Check if an active consent exists for a user and purpose.

    Used to prevent duplicate consent grants for the same purpose.

    Args:
        db: Database session.
        user_id: ID of the user (data principal).
        purpose_id: ID of the purpose.

    Returns:
        True if an active (GRANTED) consent exists, False otherwise.
    """
    from app.models.audit import ConsentStatus

    existing = db.query(Consent).filter(
        Consent.user_id == user_id,
        Consent.purpose_id == purpose_id,
        Consent.status == ConsentStatus.GRANTED
    ).first()

    return existing is not None
